
# ðŸš‚ 3-26 ASM Programming - Knowledge

[Back to README](README.md)


## Primer Contents

In this tutorial, we will go over the following topics:

- [Programming](#programming)
- [Compilations](#compilations)
- [Architectures](#architectures)
- [Relative and Absolute Addressing](#relative-and-absolute-addressing)
- [Macros](#macros)
- [Sources](#sources)
- [Required Additional Readings](#required-additional-readings)
- [Resources](#resources)


## Programming

Congratulations, you are now an assembly programmer. The module will discuss 
a couple more things to add to your assembly programming tool belt. You can 
write assembly programs for all kinds of applications. After this course, you 
may want to expand your assembly knowledge to other architectures or different 
types of assembly such as ARM or MIPS. Assembly programming can be done as 
a whole program or as parts of a program written in another language. It can 
also be used in operating system development, language developement, security 
development, and many other fields.


## Compilations

As discussed in previous modules, there are several ways to assemble compile 
assembly. The two ways highlighted in this course is with `nasm` and then `ld` 
or with `nasm` and then `gcc`. The `nasm` and `ld` method requires a 
`global _start` function to act as the entry point and an `exit` syscall to 
exit the process. Whereas the `nasm` and `gcc` method requires a `global main` 
function which can return. The `nasm` and then `gcc` method has some more 
setup routines for the process and includes `libc`, whereas the `nasm` and 
then `ld` method does not. With nasm, you have to specify the target assembly 
format using the `-f` option. To find out more information about `nasm` and 
`gcc` options, try `man nasm` or `man gcc` or look up the manuals online. We 
did not go over compilation on Windows in this course, but you can look up 
`masm` or one of the other assemblers online to find out more information on 
how to build programs using different assemblers and different formats and 
techniques. You can even compile for Windows on Linux or vice versa. 


## Architectures

You can use the `bits <number>` directive in `nasm` to specify the target 
processor mode. This effectives the addressing rules of `nasm`. This causes 
the machine code generated by `nasm` to have certain variations for different 
processors. For example, declaring `bits 32` on a program you want to run in 
on a 16-bit processor (or a 16-bit processor mode), the machine code would be 
different than if you did not and you may have problems. Sometimes these 
directives are needed to get your compilation to work the way you want on 
different processors. You do not need to use these for this course, but you 
should be aware that different processors may need variations to machine code 
to understand all the instructions. See the [`nasm` manual
](https://www.nasm.us/doc/nasmdoc7.html#section-7.1) for more information.


## Relative and Absolute Addressing

You can preface addresses with `rel` or `abs` to change the default addressing 
for that address, or you can use `default rel` or `default abs` to change the 
default for the program. You may need to consider this if writing position-
independent code, but you do not have to use this for this course; it is just 
another FYI. 

This sets whether registerless instructions in 64-bit mode are RIPâ€“relative or
not. By default, they are absolute unless overridden with the `REL` specifier
(see section 3.3 Effective addresses). However, if `DEFAULT REL` is specified,
`REL` is default, unless overridden with the `ABS` specifier, except when used
with an `FS` or `GS` segment override. The special handling of `FS` and `GS`
overrides are due to the fact that these registers are generally used as thread
pointers or other special functions in 64-bit mode, and generating
`RIP`-relative addresses would be extremely confusing. `DEFAULT REL` is
disabled with `DEFAULT ABS` [[1]](#sources).


## Macros

Writing a macro is another way of ensuring modular programming in assembly
language. A macro is a sequence of instructions, assigned by a name and could
be used anywhere in the program. In `NASM`, macros are defined with `%macro`
and `%endmacro` directives [[2]](#sources).

``` x86asm
%macro <macro_name> <number_of_params>
    <macro body>
%endmacro
```

Where, `<number_of_params>` specifies the number parameters, `<macro_name>`
specifies the name of the macro [[2]](#sources).

The macro is invoked by using the macro name along with the necessary
parameters. When you need to use some sequence of instructions many times in a
program, you can put those instructions in a macro and use it instead of
writing the instructions all the time [[2]](#sources).

For example, a very common need for programs is to write a string of characters
in the screen. For displaying a string of characters, you need the following
sequence of instructions [[2]](#sources):

``` x86asm
mov	edx,len	    ;message length
mov	ecx,msg	    ;message to write
mov	ebx,1       ;file descriptor (stdout)
mov	eax,4       ;system call number (sys_write)
int	0x80        ;call kernel
```
[[2]](#sources)

In the above example of displaying a character string, the registers `EAX`,
`EBX`, `ECX` and `EDX` have been used by the `INT 80H` function call. So, each
time you need to display on screen, you need to save these registers on the
stack, invoke `INT 80H` and then restore the original value of the registers
from the stack. So, it could be useful to write two macros for saving and
restoring data [[2]](#sources).

We have observed that, some instructions like `IMUL`, `IDIV`, `INT`, etc., need
some of the information to be stored in some particular registers and even
return values in some specific register(s). If the program was already using
those registers for keeping important data, then the existing data from these
registers should be saved in the stack and restored after the instruction is
executed [[2]](#sources).

Following example shows defining and using macros [[2]](#sources):

``` x86asm
; A macro with two parameters
; Implements the write system call
   %macro write_string 2 
      mov   eax, 4
      mov   ebx, 1
      mov   ecx, %1
      mov   edx, %2
      int   80h
   %endmacro
 
section	.text
   global _start            ;must be declared for using gcc
	
_start:                     ;tell linker entry point
   write_string msg1, len1               
   write_string msg2, len2    
   write_string msg3, len3  
	
   mov eax,1                ;system call number (sys_exit)
   int 0x80                 ;call kernel

section	.data
msg1 db	'Hello, programmers!',0xA,0xD 	
len1 equ $ - msg1			

msg2 db 'Welcome to the world of,', 0xA,0xD 
len2 equ $- msg2 

msg3 db 'Linux assembly programming! '
len3 equ $- msg3
```
[[2]](#sources)

When the above code is compiled and executed, it produces the following result
[[2]](#sources):

```
Hello, programmers!
Welcome to the world of,
Linux assembly programming!
```
[[2]](#sources):
  

## Sources

1. *Chapter 7: Assembler Directives*. 
https://www.nasm.us/doc/nasmdoc7.html#section-7.2.
2. *Assembly - Macros*. 
https://www.tutorialspoint.com/assembly_programming/assembly_macros.htm.


## Required Additional Readings

None.


## Resources

1. ***NASM - The Netwide Assembler***. 
https://www.nasm.us/doc/nasmdoc0.html. 
NASM Manual.  


[Back to Contents](#primer-contents)

[Back to README](README.md)

<link rel="stylesheet" href="../.css/boxes.css">



<!--- End of file. --->
